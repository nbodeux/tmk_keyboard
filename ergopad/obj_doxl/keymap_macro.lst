   1               		.file	"keymap_macro.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.promicro_bootloader_jmp,"ax",@progbits
  11               	.global	promicro_bootloader_jmp
  13               	promicro_bootloader_jmp:
  14               	.LFB105:
  15               		.file 1 "keymap_macro.c"
   1:keymap_macro.c **** #include "keymap_common.h"
   2:keymap_macro.c **** #include <avr/wdt.h>
   3:keymap_macro.c **** 
   4:keymap_macro.c **** /* id for user defined functions */
   5:keymap_macro.c **** enum function_id {
   6:keymap_macro.c ****     PROMICRO_PROGRAM,
   7:keymap_macro.c **** };
   8:keymap_macro.c **** 
   9:keymap_macro.c **** /*
  10:keymap_macro.c ****  * Macropad
  11:keymap_macro.c ****  */
  12:keymap_macro.c **** const uint8_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
  13:keymap_macro.c ****     /* Keymap 0: Default Layer */
  14:keymap_macro.c ****     KEYMAP(
  15:keymap_macro.c ****                  FN0,     FN1, FN2, FN3, FN4,   \
  16:keymap_macro.c ****                  NLCK,
  17:keymap_macro.c ****                           PPLS,PSLS,PAST,PMNS, \
  18:keymap_macro.c ****        INS, HOME,PGUP,    P7,  P8,  P9,  DEL,  \
  19:keymap_macro.c ****        DEL, END, PGDN,    P4,  P5,  P6,  LEFT, \
  20:keymap_macro.c ****        VOLD,UP,  VOLU,    P1,  P2,  P3,  RGHT, \
  21:keymap_macro.c ****        LEFT,DOWN,RGHT,    P0,  BSPC,PDOT,ENT),
  22:keymap_macro.c ****     /* Keymap 1: Function Keys */
  23:keymap_macro.c ****     KEYMAP(
  24:keymap_macro.c ****                  FN0,     FN1, FN2, FN3, FN4,   \
  25:keymap_macro.c ****                  NLCK,
  26:keymap_macro.c ****                           PPLS,PSLS,PAST,PMNS, \
  27:keymap_macro.c ****        F1,  F2,  F3,      P7,  P8,  P9,  DEL,  \
  28:keymap_macro.c ****        F4,  F5,  F6,      P4,  P5,  P6,  LEFT, \
  29:keymap_macro.c ****        F7,  F8,  F9,      P1,  P2,  P3,  RGHT, \
  30:keymap_macro.c ****        F10, F11, F12,     P0,  BSPC,PDOT,ENT),
  31:keymap_macro.c ****     /* Keymap 2: Extended function keys*/
  32:keymap_macro.c ****     KEYMAP(
  33:keymap_macro.c ****                  FN25,     FN1, FN2, FN3, FN4,   \
  34:keymap_macro.c ****                  FN26,
  35:keymap_macro.c ****                           PPLS,PSLS,PAST,PMNS, \
  36:keymap_macro.c ****        F13, F14, F15,     P7,  P8,  P9,  DEL,  \
  37:keymap_macro.c ****        F16, F17, F18,     P4,  P5,  P6,  LEFT, \
  38:keymap_macro.c ****        F19, F20, F21,     P1,  P2,  P3,  RGHT, \
  39:keymap_macro.c ****        F22, F23, F24,     P0,  BSPC,PDOT,ENT),
  40:keymap_macro.c ****     /* Keymap 3: Shifted function keys */
  41:keymap_macro.c ****     KEYMAP(
  42:keymap_macro.c ****                  FN25,     FN1, FN2, FN3, FN4,   \
  43:keymap_macro.c ****                  FN26,
  44:keymap_macro.c ****                           PPLS,PSLS,PAST,PMNS, \
  45:keymap_macro.c ****        FN13,FN14,FN15,    P7,  P8,  P9,  DEL,  \
  46:keymap_macro.c ****        FN16,FN17,FN18,    P4,  P5,  P6,  LEFT, \
  47:keymap_macro.c ****        FN19,FN20,FN21,    P1,  P2,  P3,  RGHT, \
  48:keymap_macro.c ****        FN22,FN23,FN24,    P0,  BSPC,PDOT,ENT),   
  49:keymap_macro.c ****     /* Keymap 4: Shifted function keys */
  50:keymap_macro.c ****     KEYMAP(
  51:keymap_macro.c ****                  TRNS,    FN1, FN2, FN3, FN4,   \
  52:keymap_macro.c ****                  FN5,
  53:keymap_macro.c ****                           PPLS,PSLS,PAST,PMNS, \
  54:keymap_macro.c ****        TRNS,TRNS,TRNS,    P7,  P8,  P9,  DEL,  \
  55:keymap_macro.c ****        TRNS,TRNS,TRNS,    P4,  P5,  P6,  LEFT, \
  56:keymap_macro.c ****        TRNS,TRNS,TRNS,    P1,  P2,  P3,  RGHT, \
  57:keymap_macro.c ****        TRNS,TRNS,TRNS,    P0,  BSPC,PDOT,ENT),
  58:keymap_macro.c **** };
  59:keymap_macro.c **** 
  60:keymap_macro.c **** /*
  61:keymap_macro.c ****  * Fn action definition
  62:keymap_macro.c ****  */
  63:keymap_macro.c **** const action_t PROGMEM fn_actions[] = {
  64:keymap_macro.c ****     [0] = ACTION_LAYER_TAP_KEY(4, KC_PSCR), //switch to the sneaky layer
  65:keymap_macro.c ****     [1] = ACTION_DEFAULT_LAYER_SET(0),  // set default layout
  66:keymap_macro.c ****     [2] = ACTION_DEFAULT_LAYER_SET(1),  // set function keys
  67:keymap_macro.c ****     [3] = ACTION_DEFAULT_LAYER_SET(2),  // set macros
  68:keymap_macro.c ****     [4] = ACTION_DEFAULT_LAYER_SET(3),  // set shifted macros
  69:keymap_macro.c ****     [5] = ACTION_FUNCTION(PROMICRO_PROGRAM),
  70:keymap_macro.c ****     //Macro record keys
  71:keymap_macro.c ****     [10] = ACTION_MODS_KEY(MOD_LSFT, KC_F1), //Combo key that I decided not to use
  72:keymap_macro.c ****     [11] = ACTION_MODS_KEY(MOD_LSFT, KC_F2), //Another one
  73:keymap_macro.c ****     
  74:keymap_macro.c ****     //Shifted fuction keys starting from F13
  75:keymap_macro.c ****     [13] = ACTION_MODS_KEY(MOD_LSFT, KC_F13),
  76:keymap_macro.c ****     [14] = ACTION_MODS_KEY(MOD_LSFT, KC_F14),
  77:keymap_macro.c ****     [15] = ACTION_MODS_KEY(MOD_LSFT, KC_F15),
  78:keymap_macro.c ****     [16] = ACTION_MODS_KEY(MOD_LSFT, KC_F16),
  79:keymap_macro.c ****     [17] = ACTION_MODS_KEY(MOD_LSFT, KC_F17),
  80:keymap_macro.c ****     [18] = ACTION_MODS_KEY(MOD_LSFT, KC_F18),
  81:keymap_macro.c ****     [19] = ACTION_MODS_KEY(MOD_LSFT, KC_F19),
  82:keymap_macro.c ****     [20] = ACTION_MODS_KEY(MOD_LSFT, KC_F20),
  83:keymap_macro.c ****     [21] = ACTION_MODS_KEY(MOD_LSFT, KC_F21),
  84:keymap_macro.c ****     [22] = ACTION_MODS_KEY(MOD_LSFT, KC_F22),
  85:keymap_macro.c ****     [23] = ACTION_MODS_KEY(MOD_LSFT, KC_F23),
  86:keymap_macro.c ****     [24] = ACTION_MODS_KEY(MOD_LSFT, KC_F24),
  87:keymap_macro.c **** 
  88:keymap_macro.c ****     [25] = ACTION_MODS_KEY(MOD_LCTL, KC_F12),
  89:keymap_macro.c ****     [26] = ACTION_MODS_KEY(MOD_LCTL, KC_F13),
  90:keymap_macro.c ****   
  91:keymap_macro.c **** };
  92:keymap_macro.c **** 
  93:keymap_macro.c **** void promicro_bootloader_jmp(bool program) {
  16               		.loc 1 93 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  94:keymap_macro.c ****     uint16_t *const bootKeyPtr = (uint16_t *)0x0800;
  95:keymap_macro.c **** 
  96:keymap_macro.c ****     // Value used by Caterina bootloader use to determine whether to run the
  97:keymap_macro.c ****     // sketch or the bootloader programmer.
  98:keymap_macro.c ****     uint16_t bootKey = program ? 0x7777 : 0;
  23               		.loc 1 98 0
  24 0000 8111      		cpse r24,__zero_reg__
  25 0002 00C0      		rjmp .L4
  26 0004 80E0      		ldi r24,0
  27 0006 90E0      		ldi r25,0
  28               	.LVL1:
  29 0008 00C0      		rjmp .L2
  30               	.LVL2:
  31               	.L4:
  32 000a 87E7      		ldi r24,lo8(119)
  33 000c 97E7      		ldi r25,lo8(119)
  34               	.LVL3:
  35               	.L2:
  99:keymap_macro.c **** 
 100:keymap_macro.c ****     *bootKeyPtr = bootKey;
  36               		.loc 1 100 0 discriminator 4
  37 000e 9093 0108 		sts 2048+1,r25
  38 0012 8093 0008 		sts 2048,r24
  39               	.LVL4:
  40               	.LBB4:
  41               	.LBB5:
  42               		.file 2 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
  43               		.loc 2 473 0 discriminator 4
  44 0016 9AE0      		ldi r25,lo8(10)
  45 0018 88E1      		ldi r24,lo8(24)
  46               	.LVL5:
  47               	/* #APP */
  48               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
  49 001a 0FB6      		in __tmp_reg__,__SREG__
  50 001c F894      		cli
  51 001e A895      		wdr
  52 0020 8093 6000 		sts 96, r24
  53 0024 0FBE      		out __SREG__,__tmp_reg__
  54 0026 9093 6000 		sts 96, r25
  55               	 	
  56               	 ;  0 "" 2
  57               	/* #NOAPP */
  58               	.L3:
  59 002a 00C0      		rjmp .L3
  60               	.LBE5:
  61               	.LBE4:
  62               		.cfi_endproc
  63               	.LFE105:
  65               		.section	.text.action_function,"ax",@progbits
  66               	.global	action_function
  68               	action_function:
  69               	.LFB106:
 101:keymap_macro.c **** 
 102:keymap_macro.c ****     // setup watchdog timeout
 103:keymap_macro.c ****     wdt_enable(WDTO_60MS);
 104:keymap_macro.c **** 
 105:keymap_macro.c ****     while(1) {} // wait for watchdog timer to trigger
 106:keymap_macro.c **** }
 107:keymap_macro.c **** 
 108:keymap_macro.c **** /*
 109:keymap_macro.c **** * user defined action function
 110:keymap_macro.c **** */
 111:keymap_macro.c **** void action_function(keyrecord_t *record, uint8_t id, uint8_t opt)
 112:keymap_macro.c **** {
  70               		.loc 1 112 0
  71               		.cfi_startproc
  72               	.LVL6:
  73               	/* prologue: function */
  74               	/* frame size = 0 */
  75               	/* stack size = 0 */
  76               	.L__stack_usage = 0
 113:keymap_macro.c ****     switch (id) {
  77               		.loc 1 113 0
  78 0000 6111      		cpse r22,__zero_reg__
  79 0002 00C0      		rjmp .L9
 114:keymap_macro.c ****         case PROMICRO_PROGRAM:
 115:keymap_macro.c ****             promicro_bootloader_jmp(true);
  80               		.loc 1 115 0
  81 0004 81E0      		ldi r24,lo8(1)
  82               	.LVL7:
  83 0006 0E94 0000 		call promicro_bootloader_jmp
  84               	.LVL8:
  85               	.L9:
  86 000a 0895      		ret
  87               		.cfi_endproc
  88               	.LFE106:
  90               	.global	fn_actions
  91               		.section	.progmem.data.fn_actions,"a",@progbits
  94               	fn_actions:
  95 0000 46A4      		.word	-23482
  96 0002 018C      		.word	-29695
  97 0004 028C      		.word	-29694
  98 0006 048C      		.word	-29692
  99 0008 088C      		.word	-29688
 100 000a 00F0      		.word	-4096
 101 000c 0000 0000 		.zero	8
 101      0000 0000 
 102 0014 3A02      		.word	570
 103 0016 3B02      		.word	571
 104 0018 0000      		.zero	2
 105 001a 6802      		.word	616
 106 001c 6902      		.word	617
 107 001e 6A02      		.word	618
 108 0020 6B02      		.word	619
 109 0022 6C02      		.word	620
 110 0024 6D02      		.word	621
 111 0026 6E02      		.word	622
 112 0028 6F02      		.word	623
 113 002a 7002      		.word	624
 114 002c 7102      		.word	625
 115 002e 7202      		.word	626
 116 0030 7302      		.word	627
 117 0032 4501      		.word	325
 118 0034 6801      		.word	360
 119               	.global	keymaps
 120               		.section	.progmem.data.keymaps,"a",@progbits
 123               	keymaps:
 124 0000 00        		.byte	0
 125 0001 00        		.byte	0
 126 0002 C0        		.byte	-64
 127 0003 C1        		.byte	-63
 128 0004 C2        		.byte	-62
 129 0005 C3        		.byte	-61
 130 0006 C4        		.byte	-60
 131 0007 00        		.byte	0
 132 0008 00        		.byte	0
 133 0009 53        		.byte	83
 134 000a 57        		.byte	87
 135 000b 54        		.byte	84
 136 000c 55        		.byte	85
 137 000d 56        		.byte	86
 138 000e 49        		.byte	73
 139 000f 4A        		.byte	74
 140 0010 4B        		.byte	75
 141 0011 5F        		.byte	95
 142 0012 60        		.byte	96
 143 0013 61        		.byte	97
 144 0014 4C        		.byte	76
 145 0015 4C        		.byte	76
 146 0016 4D        		.byte	77
 147 0017 4E        		.byte	78
 148 0018 5C        		.byte	92
 149 0019 5D        		.byte	93
 150 001a 5E        		.byte	94
 151 001b 50        		.byte	80
 152 001c AA        		.byte	-86
 153 001d 52        		.byte	82
 154 001e A9        		.byte	-87
 155 001f 59        		.byte	89
 156 0020 5A        		.byte	90
 157 0021 5B        		.byte	91
 158 0022 4F        		.byte	79
 159 0023 50        		.byte	80
 160 0024 51        		.byte	81
 161 0025 4F        		.byte	79
 162 0026 62        		.byte	98
 163 0027 2A        		.byte	42
 164 0028 63        		.byte	99
 165 0029 28        		.byte	40
 166 002a 00        		.byte	0
 167 002b 00        		.byte	0
 168 002c C0        		.byte	-64
 169 002d C1        		.byte	-63
 170 002e C2        		.byte	-62
 171 002f C3        		.byte	-61
 172 0030 C4        		.byte	-60
 173 0031 00        		.byte	0
 174 0032 00        		.byte	0
 175 0033 53        		.byte	83
 176 0034 57        		.byte	87
 177 0035 54        		.byte	84
 178 0036 55        		.byte	85
 179 0037 56        		.byte	86
 180 0038 3A        		.byte	58
 181 0039 3B        		.byte	59
 182 003a 3C        		.byte	60
 183 003b 5F        		.byte	95
 184 003c 60        		.byte	96
 185 003d 61        		.byte	97
 186 003e 4C        		.byte	76
 187 003f 3D        		.byte	61
 188 0040 3E        		.byte	62
 189 0041 3F        		.byte	63
 190 0042 5C        		.byte	92
 191 0043 5D        		.byte	93
 192 0044 5E        		.byte	94
 193 0045 50        		.byte	80
 194 0046 40        		.byte	64
 195 0047 41        		.byte	65
 196 0048 42        		.byte	66
 197 0049 59        		.byte	89
 198 004a 5A        		.byte	90
 199 004b 5B        		.byte	91
 200 004c 4F        		.byte	79
 201 004d 43        		.byte	67
 202 004e 44        		.byte	68
 203 004f 45        		.byte	69
 204 0050 62        		.byte	98
 205 0051 2A        		.byte	42
 206 0052 63        		.byte	99
 207 0053 28        		.byte	40
 208 0054 00        		.byte	0
 209 0055 00        		.byte	0
 210 0056 D9        		.byte	-39
 211 0057 C1        		.byte	-63
 212 0058 C2        		.byte	-62
 213 0059 C3        		.byte	-61
 214 005a C4        		.byte	-60
 215 005b 00        		.byte	0
 216 005c 00        		.byte	0
 217 005d DA        		.byte	-38
 218 005e 57        		.byte	87
 219 005f 54        		.byte	84
 220 0060 55        		.byte	85
 221 0061 56        		.byte	86
 222 0062 68        		.byte	104
 223 0063 69        		.byte	105
 224 0064 6A        		.byte	106
 225 0065 5F        		.byte	95
 226 0066 60        		.byte	96
 227 0067 61        		.byte	97
 228 0068 4C        		.byte	76
 229 0069 6B        		.byte	107
 230 006a 6C        		.byte	108
 231 006b 6D        		.byte	109
 232 006c 5C        		.byte	92
 233 006d 5D        		.byte	93
 234 006e 5E        		.byte	94
 235 006f 50        		.byte	80
 236 0070 6E        		.byte	110
 237 0071 6F        		.byte	111
 238 0072 70        		.byte	112
 239 0073 59        		.byte	89
 240 0074 5A        		.byte	90
 241 0075 5B        		.byte	91
 242 0076 4F        		.byte	79
 243 0077 71        		.byte	113
 244 0078 72        		.byte	114
 245 0079 73        		.byte	115
 246 007a 62        		.byte	98
 247 007b 2A        		.byte	42
 248 007c 63        		.byte	99
 249 007d 28        		.byte	40
 250 007e 00        		.byte	0
 251 007f 00        		.byte	0
 252 0080 D9        		.byte	-39
 253 0081 C1        		.byte	-63
 254 0082 C2        		.byte	-62
 255 0083 C3        		.byte	-61
 256 0084 C4        		.byte	-60
 257 0085 00        		.byte	0
 258 0086 00        		.byte	0
 259 0087 DA        		.byte	-38
 260 0088 57        		.byte	87
 261 0089 54        		.byte	84
 262 008a 55        		.byte	85
 263 008b 56        		.byte	86
 264 008c CD        		.byte	-51
 265 008d CE        		.byte	-50
 266 008e CF        		.byte	-49
 267 008f 5F        		.byte	95
 268 0090 60        		.byte	96
 269 0091 61        		.byte	97
 270 0092 4C        		.byte	76
 271 0093 D0        		.byte	-48
 272 0094 D1        		.byte	-47
 273 0095 D2        		.byte	-46
 274 0096 5C        		.byte	92
 275 0097 5D        		.byte	93
 276 0098 5E        		.byte	94
 277 0099 50        		.byte	80
 278 009a D3        		.byte	-45
 279 009b D4        		.byte	-44
 280 009c D5        		.byte	-43
 281 009d 59        		.byte	89
 282 009e 5A        		.byte	90
 283 009f 5B        		.byte	91
 284 00a0 4F        		.byte	79
 285 00a1 D6        		.byte	-42
 286 00a2 D7        		.byte	-41
 287 00a3 D8        		.byte	-40
 288 00a4 62        		.byte	98
 289 00a5 2A        		.byte	42
 290 00a6 63        		.byte	99
 291 00a7 28        		.byte	40
 292 00a8 00        		.byte	0
 293 00a9 00        		.byte	0
 294 00aa 01        		.byte	1
 295 00ab C1        		.byte	-63
 296 00ac C2        		.byte	-62
 297 00ad C3        		.byte	-61
 298 00ae C4        		.byte	-60
 299 00af 00        		.byte	0
 300 00b0 00        		.byte	0
 301 00b1 C5        		.byte	-59
 302 00b2 57        		.byte	87
 303 00b3 54        		.byte	84
 304 00b4 55        		.byte	85
 305 00b5 56        		.byte	86
 306 00b6 01        		.byte	1
 307 00b7 01        		.byte	1
 308 00b8 01        		.byte	1
 309 00b9 5F        		.byte	95
 310 00ba 60        		.byte	96
 311 00bb 61        		.byte	97
 312 00bc 4C        		.byte	76
 313 00bd 01        		.byte	1
 314 00be 01        		.byte	1
 315 00bf 01        		.byte	1
 316 00c0 5C        		.byte	92
 317 00c1 5D        		.byte	93
 318 00c2 5E        		.byte	94
 319 00c3 50        		.byte	80
 320 00c4 01        		.byte	1
 321 00c5 01        		.byte	1
 322 00c6 01        		.byte	1
 323 00c7 59        		.byte	89
 324 00c8 5A        		.byte	90
 325 00c9 5B        		.byte	91
 326 00ca 4F        		.byte	79
 327 00cb 01        		.byte	1
 328 00cc 01        		.byte	1
 329 00cd 01        		.byte	1
 330 00ce 62        		.byte	98
 331 00cf 2A        		.byte	42
 332 00d0 63        		.byte	99
 333 00d1 28        		.byte	40
 334               		.text
 335               	.Letext0:
 336               		.file 3 "/usr/lib/avr/include/stdint.h"
 337               		.file 4 "../../tmk_core/common/keycode.h"
 338               		.file 5 "../../tmk_core/common/keyboard.h"
 339               		.file 6 "../../tmk_core/common/action_code.h"
 340               		.file 7 "../../tmk_core/common/action.h"
 341               		.file 8 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 keymap_macro.c
     /tmp/ccn4qHjJ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccn4qHjJ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccn4qHjJ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccn4qHjJ.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccn4qHjJ.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccn4qHjJ.s:13     .text.promicro_bootloader_jmp:0000000000000000 promicro_bootloader_jmp
     /tmp/ccn4qHjJ.s:68     .text.action_function:0000000000000000 action_function
     /tmp/ccn4qHjJ.s:94     .progmem.data.fn_actions:0000000000000000 fn_actions
     /tmp/ccn4qHjJ.s:123    .progmem.data.keymaps:0000000000000000 keymaps

NO UNDEFINED SYMBOLS
